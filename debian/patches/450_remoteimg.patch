Subject: Support OSC 5379 remote imaging and sixel graphics
Author: Araki Ken <arakiken@users.sf.net>
Origin: https://bitbucket.org/arakiken/w3m/branch/remoteimg

diff --git a/display.c b/display.c
index 2fe1183..d4f336a 100644
--- a/display.c
+++ b/display.c
@@ -487,7 +487,7 @@ displayBuffer(Buffer *buf, int mode)
     term_title(conv_to_system(buf->buffername));
     refresh();
 #ifdef USE_IMAGE
-    if (activeImage && displayImage && buf->img) {
+    if (activeImage && displayImage && buf->img && buf->image_loaded) {
 	drawImage();
     }
 #endif
@@ -521,7 +521,15 @@ drawAnchorCursor0(Buffer *buf, AnchorList *al, int hseq, int prevhseq,
 		break;
 	}
 	if (hseq >= 0 && an->hseq == hseq) {
+	    int start_pos = an->start.pos;
+	    int end_pos = an->end.pos;
 	    for (i = an->start.pos; i < an->end.pos; i++) {
+	        if (enable_inline_image && (l->propBuf[i] & PE_IMAGE)) {
+		    if (start_pos == i)
+			start_pos = i + 1;
+		    else if (end_pos == an->end.pos)
+		        end_pos = i - 1;
+		}
 		if (l->propBuf[i] & (PE_IMAGE | PE_ANCHOR | PE_FORM)) {
 		    if (active)
 			l->propBuf[i] |= PE_ACTIVE;
@@ -529,9 +537,9 @@ drawAnchorCursor0(Buffer *buf, AnchorList *al, int hseq, int prevhseq,
 			l->propBuf[i] &= ~PE_ACTIVE;
 		}
 	    }
-	    if (active)
+	    if (active && start_pos < end_pos)
 		redrawLineRegion(buf, l, l->linenumber - tline + buf->rootY,
-				 an->start.pos, an->end.pos);
+				 start_pos, end_pos);
 	}
 	else if (prevhseq >= 0 && an->hseq == prevhseq) {
 	    if (active)
@@ -855,14 +863,16 @@ redrawLineImage(Buffer *buf, Line *l, int i)
 		y = (int)(i * pixel_per_line);
 		sx = (int)((rcol - COLPOS(l, a->start.pos)) * pixel_per_char);
 		sy = (int)((l->linenumber - image->y) * pixel_per_line);
-		if (sx == 0 && x + image->xoffset >= 0)
-		    x += image->xoffset;
-		else
-		    sx -= image->xoffset;
-		if (sy == 0 && y + image->yoffset >= 0)
-		    y += image->yoffset;
-		else
-		    sy -= image->yoffset;
+		if (! enable_inline_image) {
+		    if (sx == 0 && x + image->xoffset >= 0)
+			x += image->xoffset;
+		    else
+			sx -= image->xoffset;
+		    if (sy == 0 && y + image->yoffset >= 0)
+			y += image->yoffset;
+		    else
+			sy -= image->yoffset;
+		}
 		if (image->width > 0)
 		    w = image->width - sx;
 		else
diff --git a/doc/README.sixel b/doc/README.sixel
new file mode 100644
index 0000000..588afc4
--- /dev/null
+++ b/doc/README.sixel
@@ -0,0 +1,27 @@
+Sixel support of w3m
+                                                              2014/11/05
+                                                              K. Araki
+
+Introduction
+
+  This is the extension for w3m to show inline images by sixel graphics.
+
+Requirements
+
+  Install 'img2sixel' command provided by libsixel project.
+  (https://github.com/saitoha/libsixel)
+
+Build
+
+  $ ./configure --enable-image ...
+  $ make
+  $ make install
+
+Usage
+
+  $ w3m -sixel http://...
+
+  You can specify options of 'img2sixel' command by "W3M_IMG2SIXEL"
+  environmental variable.
+
+  $ W3M_IMG2SIXEL="img2sixel -d atkinson" w3m -sixel http://...
diff --git a/etc.c b/etc.c
index 8fe1215..dcc6edd 100644
--- a/etc.c
+++ b/etc.c
@@ -1365,7 +1365,13 @@ setup_child(int child, int i, int f)
     if (!child)
 	SETPGRP();
 #endif /* __MINGW32_VERSION */
+    /*
+     * I don't know why but close_tty() sometimes interrupts loadGeneralFile() in loadImage()
+     * and corrupt image data can be cached in ~/.w3m.
+     */
+#if 0
     close_tty();
+#endif
     close_all_fds_except(i, f);
     QuietMessage = TRUE;
     fmInitialized = FALSE;
diff --git a/file.c b/file.c
index 1e363d0..709a0c1 100644
--- a/file.c
+++ b/file.c
@@ -3345,8 +3345,14 @@ process_img(struct parsed_tag *tag, int width)
 	    if (i < 0)
 		i = pixel_per_line;
 	}
-	nw = (w > 3) ? (int)((w - 3) / pixel_per_char + 1) : 1;
-	ni = (i > 3) ? (int)((i - 3) / pixel_per_line + 1) : 1;
+	if (enable_inline_image) {
+	    nw = (w > 1) ? ((w - 1) / pixel_per_char_i + 1) : 1 ;
+	    ni = (i > 1) ? ((i - 1) / pixel_per_line_i + 1) : 1 ;
+	}
+	else {
+	    nw = (w > 3) ? (int)((w - 3) / pixel_per_char + 1) : 1;
+	    ni = (i > 3) ? (int)((i - 3) / pixel_per_line + 1) : 1;
+	}
 	Strcat(tmp,
 	       Sprintf("<pre_int><img_alt hseq=\"%d\" src=\"", cur_iseq++));
 	pre_int = TRUE;
@@ -3377,19 +3383,21 @@ process_img(struct parsed_tag *tag, int width)
 	if (i0 >= 0)
 	    Strcat(tmp, Sprintf(" height=%d", i0));
 	switch (align) {
+	case ALIGN_MIDDLE:
+	    if (!enable_inline_image) {
+		top = ni / 2;
+		bottom = top;
+		if (top * 2 == ni)
+		    yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);
+		else
+		    yoffset = (int)((ni * pixel_per_line - i) / 2);
+		break;
+	    }
 	case ALIGN_TOP:
 	    top = 0;
 	    bottom = ni - 1;
 	    yoffset = 0;
 	    break;
-	case ALIGN_MIDDLE:
-	    top = ni / 2;
-	    bottom = top;
-	    if (top * 2 == ni)
-		yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);
-	    else
-		yoffset = (int)((ni * pixel_per_line - i) / 2);
-	    break;
 	case ALIGN_BOTTOM:
 	    top = ni - 1;
 	    bottom = 0;
@@ -3407,7 +3415,12 @@ process_img(struct parsed_tag *tag, int width)
 	    }
 	    break;
 	}
-	xoffset = (int)((nw * pixel_per_char - w) / 2);
+
+	if (enable_inline_image)
+	    xoffset = 0;
+	else
+	    xoffset = (int)((nw * pixel_per_char - w) / 2);
+
 	if (xoffset)
 	    Strcat(tmp, Sprintf(" xoffset=%d", xoffset));
 	if (yoffset)
diff --git a/fm.h b/fm.h
index 49af0e4..8f594dc 100644
--- a/fm.h
+++ b/fm.h
@@ -373,6 +373,8 @@ typedef struct _imageCache {
     int index;
     short width;
     short height;
+    short a_width;
+    short a_height;
 } ImageCache;
 
 typedef struct _image {
@@ -919,6 +921,7 @@ global char *CurrentKeyData;
 global char *CurrentCmdData;
 global char *w3m_reqlog;
 extern char *w3m_version;
+extern int enable_inline_image;
 
 #define DUMP_BUFFER   0x01
 #define DUMP_HEAD     0x02
@@ -1174,9 +1177,11 @@ global char *ssl_forbid_method init("2, 3");
 global int is_redisplay init(FALSE);
 global int clear_buffer init(TRUE);
 global double pixel_per_char init(DEFAULT_PIXEL_PER_CHAR);
+global int pixel_per_char_i init(DEFAULT_PIXEL_PER_CHAR);
 global int set_pixel_per_char init(FALSE);
 #ifdef USE_IMAGE
 global double pixel_per_line init(DEFAULT_PIXEL_PER_LINE);
+global int pixel_per_line_i init(DEFAULT_PIXEL_PER_LINE);
 global int set_pixel_per_line init(FALSE);
 global double image_scale init(100);
 #endif
diff --git a/image.c b/image.c
index 9d0e9b5..91034ee 100644
--- a/image.c
+++ b/image.c
@@ -44,6 +44,8 @@ initImage()
 	activeImage = TRUE;
 }
 
+int get_pixel_per_cell(int *ppc, int *ppl);
+
 int
 getCharSize()
 {
@@ -52,6 +54,24 @@ getCharSize()
     int w = 0, h = 0;
 
     set_environ("W3M_TTY", ttyname_tty());
+
+    if (enable_inline_image) {
+	int ppc, ppl;
+
+	if (get_pixel_per_cell(&ppc,&ppl)) {
+	    pixel_per_char_i = ppc ;
+	    pixel_per_line_i = ppl ;
+	    pixel_per_char = (double)ppc;
+	    pixel_per_line = (double)ppl;
+	}
+	else {
+	    pixel_per_char_i = (int)pixel_per_char;
+	    pixel_per_line_i = (int)pixel_per_line;
+	}
+
+	return  TRUE;
+    }
+
     tmp = Strnew();
     if (!strchr(Imgdisplay, '/'))
 	Strcat_m_charp(tmp, w3m_auxbin_dir(), "/", NULL);
@@ -156,6 +176,10 @@ addImage(ImageCache * cache, int x, int y, int sx, int sy, int w, int h)
 static void
 syncImage(void)
 {
+    if (enable_inline_image) {
+	return;
+    }
+
     fputs("3;\n", Imgdisplay_wf);	/* XSync() */
     fputs("4;\n", Imgdisplay_wf);	/* put '\n' */
     while (fflush(Imgdisplay_wf) != 0) {
@@ -171,12 +195,16 @@ syncImage(void)
     n_terminal_image = 0;
 }
 
+void put_image_osc5379(char *url, int x, int y, int w, int h, int sx, int sy, int sw, int sh, int n_terminal_image);
+void put_image_sixel(char *url, int x, int y, int w, int h, int sx, int sy, int sw, int sh, int n_terminal_image);
+
 void
 drawImage()
 {
     static char buf[64];
     int j, draw = FALSE;
     TerminalImage *i;
+    struct stat st ;
 
     if (!activeImage)
 	return;
@@ -184,6 +212,47 @@ drawImage()
 	return;
     for (j = 0; j < n_terminal_image; j++) {
 	i = &terminal_image[j];
+
+	if (enable_inline_image) {
+	#if 0
+	    fprintf(stderr,"file %s x %d y %d w %d h %d sx %d sy %d sw %d sh %d (ppc %d ppl %d)\n",
+		((enable_inline_image == 2 || getenv("WINDOWID")) &&
+		 i->cache->touch) ? i->cache->file : i->cache->url,
+		i->x, i->y,
+		i->cache->width > 0 ? i->cache->width : 0,
+		i->cache->height > 0 ? i->cache->height : 0,
+		i->sx, i->sy, i->width, i->height,
+		pixel_per_char_i, pixel_per_line_i);
+	#endif
+	    (enable_inline_image == 2 ? put_image_sixel : put_image_osc5379)(
+		((enable_inline_image == 2 /* sixel */ || getenv("WINDOWID")) &&
+		 /* XXX I don't know why but sometimes i->cache->file doesn't exist. */
+		 i->cache->touch && stat(i->cache->file,&st) == 0) ?
+			/* local */ i->cache->file : /* remote */ i->cache->url,
+		i->x / pixel_per_char_i,
+		i->y / pixel_per_line_i,
+	    #if 1
+		i->cache->a_width > 0 ?
+			(i->cache->width + i->x % pixel_per_char_i + pixel_per_char_i - 1) /
+				pixel_per_char_i :
+	    #endif
+			0,
+
+	    #if 1
+		i->cache->a_height > 0 ?
+			(i->cache->height + i->y % pixel_per_line_i + pixel_per_line_i - 1) /
+				pixel_per_line_i :
+	    #endif
+			0,
+		i->sx / pixel_per_char_i,
+		i->sy / pixel_per_line_i,
+		(i->width + i->sx % pixel_per_char_i + pixel_per_char_i - 1) / pixel_per_char_i,
+		(i->height + i->sy % pixel_per_line_i + pixel_per_line_i - 1) / pixel_per_line_i,
+		n_terminal_image);
+
+	    continue ;
+	}
+
 	if (!(i->cache->loaded & IMG_FLAG_LOADED &&
 	      i->width > 0 && i->height > 0))
 	    continue;
@@ -207,9 +276,15 @@ drawImage()
 	fputs("\n", Imgdisplay_wf);
 	draw = TRUE;
     }
-    if (!draw)
-	return;
-    syncImage();
+
+    if (!enable_inline_image) {
+	if (!draw)
+	    return;
+	syncImage();
+    }
+    else
+	n_terminal_image = 0;
+
     touch_cursor();
     refresh();
 }
@@ -321,6 +396,8 @@ showImageProgress(Buffer *buf)
 	}
     }
     if (n) {
+        if (enable_inline_image && n == l)
+	    drawImage();
 	message(Sprintf("%d/%d images loaded", l, n)->ptr,
 		buf->cursorX + buf->rootX, buf->cursorY + buf->rootY);
 	refresh();
@@ -350,7 +427,7 @@ loadImage(Buffer *buf, int flag)
     }
     for (i = 0; i < n_load_image; i++) {
 	cache = image_cache[i];
-	if (!cache)
+	if (!cache || !cache->touch)
 	    continue;
 	if (lstat(cache->touch, &st))
 	    continue;
@@ -381,7 +458,7 @@ loadImage(Buffer *buf, int flag)
 
     for (i = (buf != image_buffer) ? 0 : maxLoadImage; i < n_load_image; i++) {
 	cache = image_cache[i];
-	if (!cache)
+	if (!cache || !cache->touch)
 	    continue;
 	if (cache->pid) {
 	    kill(cache->pid, SIGKILL);
@@ -407,7 +484,8 @@ loadImage(Buffer *buf, int flag)
     }
 
     if (draw && image_buffer) {
-	drawImage();
+        if (!enable_inline_image)
+	    drawImage();
 	showImageProgress(image_buffer);
     }
 
@@ -435,6 +513,9 @@ loadImage(Buffer *buf, int flag)
 		break;
 	}
 	image_cache[i] = cache;
+	if (!cache->touch) {
+	    continue;
+	}
 
 	flush_tty();
 #ifdef DONT_CALL_GC_AFTER_FORK
@@ -515,12 +596,30 @@ getImage(Image * image, ParsedURL *current, int flag)
 	cache->url = image->url;
 	cache->current = current;
 	cache->file = tmpfname(TMPF_DFL, image->ext)->ptr;
-	cache->touch = tmpfname(TMPF_DFL, NULL)->ptr;
 	cache->pid = 0;
 	cache->index = 0;
 	cache->loaded = IMG_FLAG_UNLOADED;
-	cache->width = image->width;
-	cache->height = image->height;
+	if (enable_inline_image == 1) {
+	    if (image->width > 0 && image->width % pixel_per_char_i > 0)
+		image->width += (pixel_per_char_i - image->width % pixel_per_char_i);
+
+	    if (image->height > 0 && image->height % pixel_per_line_i > 0)
+		image->height += (pixel_per_line_i - image->height % pixel_per_line_i);
+	    if (image->height > 0 && image->width > 0) {
+		cache->loaded = IMG_FLAG_LOADED;
+	    }
+	}
+	if (cache->loaded == IMG_FLAG_UNLOADED) {
+	    cache->touch = tmpfname(TMPF_DFL, NULL)->ptr;
+	}
+	else {
+	    cache->touch = NULL;
+	}
+
+	cache->width = image->width ;
+	cache->height = image->height ;
+	cache->a_width = image->width;
+	cache->a_height = image->height;
 	putHash_sv(image_hash, key->ptr, (void *)cache);
     }
     if (flag != IMG_FLAG_SKIP) {
@@ -542,6 +641,78 @@ getImage(Image * image, ParsedURL *current, int flag)
     return cache;
 }
 
+static int
+parseImageHeader(char *path, u_int *width, u_int *height)
+{
+    FILE *fp;
+    u_char buf[8];
+
+    if (!(fp = fopen(path, "r"))) return FALSE;
+
+    if (fread(buf, 1, 2, fp) != 2) goto error;
+
+    if (memcmp(buf, "\xff\xd8", 2) == 0) {
+        /* JPEG */
+	if (fseek(fp, 2, SEEK_CUR) < 0)	goto error;   /* 0xffe0 */
+	while (fread(buf, 1, 2, fp) == 2) {
+	    size_t len = ((buf[0] << 8) | buf[1]) - 2;
+	    if (fseek(fp, len, SEEK_CUR) < 0) goto error;
+	    if (fread(buf, 1, 2, fp) == 2 &&
+	        /* SOF0 or SOF2 */
+	        (memcmp(buf, "\xff\xc0", 2) == 0 || memcmp(buf, "\xff\xc2", 2) == 0)) {
+		fseek(fp, 3, SEEK_CUR);
+		if (fread(buf, 1, 2, fp) == 2) {
+		    *height = (buf[0] << 8) | buf[1];
+		    if (fread(buf, 1, 2, fp) == 2) {
+			*width = (buf[0] << 8) | buf[1];
+			goto success;
+		    }
+		}
+		break;
+	    }
+	}
+	goto error;
+    }
+
+    if (fread(buf + 2, 1, 1, fp) != 1) goto error;
+
+    if (memcmp(buf, "GIF", 3) == 0) {
+        /* GIF */
+	if (fseek(fp, 3, SEEK_CUR) < 0) goto error;
+	if (fread(buf, 1, 2, fp) == 2) {
+	    *width = (buf[1] << 8) | buf[0];
+	    if (fread(buf, 1, 2, fp) == 2) {
+		*height = (buf[1] << 8) | buf[0];
+		goto success;
+	    }
+	}
+	goto error;
+    }
+
+    if (fread(buf + 3, 1, 5, fp) != 5) goto error;
+
+    if (memcmp(buf, "\x89\x50\x4e\x47\x0d\x0a\x1a\x0a", 8) == 0) {
+	/* PNG */
+	if (fseek(fp, 8, SEEK_CUR) < 0) goto error;
+	if (fread(buf, 1, 4, fp) == 4) {
+	    *width = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	    if (fread(buf, 1, 4, fp) == 4) {
+		*height = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+		goto success;
+	    }
+	}
+	goto error;
+    }
+
+error:
+    fclose(fp);
+    return FALSE;
+
+success:
+    fclose(fp);
+    return TRUE;
+}
+
 int
 getImageSize(ImageCache * cache)
 {
@@ -554,6 +725,10 @@ getImageSize(ImageCache * cache)
     if (!cache || !(cache->loaded & IMG_FLAG_LOADED) ||
 	(cache->width > 0 && cache->height > 0))
 	return FALSE;
+
+    if (parseImageHeader(cache->file, &w, &h))
+	goto got_image_size;
+
     tmp = Strnew();
     if (!strchr(Imgdisplay, '/'))
 	Strcat_m_charp(tmp, w3m_auxbin_dir(), "/", NULL);
@@ -569,6 +744,8 @@ getImageSize(ImageCache * cache)
 
     if (!(w > 0 && h > 0))
 	return FALSE;
+
+got_image_size:
     w = (int)(w * image_scale / 100 + 0.5);
     if (w == 0)
 	w = 1;
@@ -581,11 +758,11 @@ getImageSize(ImageCache * cache)
     }
     else if (cache->width < 0) {
 	int tmp = (int)((double)cache->height * w / h + 0.5);
-	cache->width = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
+	cache->a_width = cache->width = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
     }
     else if (cache->height < 0) {
 	int tmp = (int)((double)cache->width * h / w + 0.5);
-	cache->height = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
+	cache->a_height = cache->height = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
     }
     if (cache->width == 0)
 	cache->width = 1;
diff --git a/main.c b/main.c
index c8f1e82..32f4da2 100644
--- a/main.c
+++ b/main.c
@@ -122,6 +122,8 @@ static int searchKeyNum(void);
 #define help() fusage(stdout, 0)
 #define usage() fusage(stderr, 1)
 
+int enable_inline_image;	/* 1 == mlterm OSC 5379, 2 == sixel */
+
 static void
 fversion(FILE * f)
 {
@@ -409,7 +411,6 @@ main(int argc, char **argv, char **envp)
 #if defined(DONT_CALL_GC_AFTER_FORK) && defined(USE_IMAGE)
     char **getimage_args = NULL;
 #endif /* defined(DONT_CALL_GC_AFTER_FORK) && defined(USE_IMAGE) */
-
     GC_INIT();
 #if defined(ENABLE_NLS) || (defined(USE_M17N) && defined(HAVE_LANGINFO_CODESET))
     setlocale(LC_ALL, "");
@@ -679,6 +680,12 @@ main(int argc, char **argv, char **envp)
 		}
 	    }
 #endif
+	    else if (!strcmp("-ri", argv[i])) {
+	        enable_inline_image = 1;
+	    }
+	    else if (!strcmp("-sixel", argv[i])) {
+		enable_inline_image = 2;
+	    }
 	    else if (!strcmp("-num", argv[i]))
 		showLineNum = TRUE;
 	    else if (!strcmp("-no-proxy", argv[i]))
@@ -5910,8 +5917,14 @@ deleteFiles()
 	    Firstbuf = buf;
 	}
     }
-    while ((f = popText(fileToDelete)) != NULL)
+    while ((f = popText(fileToDelete)) != NULL) {
 	unlink(f);
+	if (enable_inline_image == 2 && strcmp(f+strlen(f)-4, ".gif") == 0) {
+	    Str firstframe = Strnew_charp(f);
+	    Strcat_charp(firstframe, "-1");
+	    unlink(firstframe->ptr);
+        }
+    }
 }
 
 void
diff --git a/terms.c b/terms.c
index 672262c..79996f1 100644
--- a/terms.c
+++ b/terms.c
@@ -12,6 +12,7 @@
 #include <unistd.h>
 #include "config.h"
 #include <string.h>
+#include <sys/wait.h>
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
@@ -466,6 +467,260 @@ writestr(char *s)
 
 #define MOVE(line,column)       writestr(tgoto(T_cm,column,line));
 
+void
+put_image_osc5379(char *url, int x, int y, int w, int h, int sx, int sy, int sw, int sh, int n_terminal_image)
+{
+    Str buf;
+    char *size ;
+
+    if (w > 0 && h > 0)
+	size = Sprintf("%dx%d",w,h)->ptr;
+    else
+	size = "";
+
+    MOVE(y,x);
+    buf = Sprintf("\x1b]5379;show_picture %s %s %dx%d+%d+%d\x07",url,size,sw,sh,sx,sy);
+    writestr(buf->ptr);
+    MOVE(Currentbuf->cursorY,Currentbuf->cursorX);
+}
+
+static void
+save_gif(const char *path, u_char *header, size_t  header_size, u_char *body, size_t body_size)
+{
+    int	fd;
+
+    if ((fd = open(path, O_WRONLY|O_CREAT, 0600)) >= 0) {
+	write(fd, header, header_size) ;
+	write(fd, body, body_size) ;
+	write(fd, "\x3b" , 1) ;
+	close(fd) ;
+    }
+}
+
+static u_char *
+skip_gif_header(u_char *p)
+{
+    /* Header */
+    p += 10;
+
+    if (*(p) & 0x80) {
+	p += (3 * (2 << ((*p) & 0x7)));
+    }
+    p += 3;
+
+    return p;
+}
+
+static Str
+save_first_animation_frame(const char *path)
+{
+    int	fd;
+    struct stat	st;
+    u_char *header;
+    size_t header_size;
+    u_char *body;
+    u_char *p;
+    ssize_t len;
+    Str new_path;
+
+    new_path = Strnew_charp(path);
+    Strcat_charp(new_path, "-1");
+    if (stat(new_path->ptr, &st) == 0) {
+	return new_path;
+    }
+
+    if ((fd = open( path, O_RDONLY)) < 0) {
+	return NULL;
+    }
+
+    if (fstat( fd, &st) != 0 || ! (header = GC_malloc( st.st_size))){
+	close( fd);
+	return NULL;
+    }
+
+    len = read(fd, header, st.st_size);
+    close(fd);
+
+    /* Header */
+
+    if (len != st.st_size || strncmp(header, "GIF89a", 6) != 0) {
+	return NULL;
+    }
+
+    p = skip_gif_header(header);
+    header_size = p - header;
+
+    /* Application Extension */
+    if (p[0] == 0x21 && p[1] == 0xff) {
+	p += 19;
+    }
+
+    /* Other blocks */
+    body = NULL;
+    while (p + 2 < header + st.st_size) {
+	if (*(p++) == 0x21 && *(p++) == 0xf9 && *(p++) == 0x04) {
+	    if( body) {
+		/* Graphic Control Extension */
+		save_gif(new_path->ptr, header, header_size, body, p - 3 - body);
+		return new_path;
+	    }
+	    else {
+		/* skip the first frame. */
+	    }
+	    body = p - 3;
+	}
+    }
+
+    return NULL;
+}
+
+void ttymode_set(int mode, int imode);
+void ttymode_reset(int mode, int imode);
+
+void
+put_image_sixel(char *url, int x, int y, int w, int h, int sx, int sy, int sw, int sh, int n_terminal_image)
+{
+    pid_t pid;
+    int do_anim;
+    MySignalHandler(*volatile previntr) (SIGNAL_ARG);
+    MySignalHandler(*volatile prevquit) (SIGNAL_ARG);
+    MySignalHandler(*volatile prevstop) (SIGNAL_ARG);
+
+    MOVE(y,x);
+    flush_tty();
+
+    do_anim = (n_terminal_image == 1 && x == 0 && y == 0 && sx == 0 && sy == 0);
+
+    previntr = mySignal(SIGINT, SIG_IGN);
+    prevquit = mySignal(SIGQUIT, SIG_IGN);
+    prevstop = mySignal(SIGTSTP, SIG_IGN);
+
+    if ((pid = fork()) == 0) {
+	char *env;
+	int n = 0;
+	char *argv[20];
+	char digit[2][11+1];
+	char clip[44+3+1];
+	Str str_url;
+
+	close(STDERR_FILENO);	/* Don't output error message. */
+	if (do_anim) {
+	    writestr("\x1b[?80h");
+	}
+	else if (!strstr(url, "://") && strcmp(url+strlen(url)-4, ".gif") == 0 &&
+                 (str_url = save_first_animation_frame(url))) {
+	    url = str_url->ptr;
+	}
+	ttymode_set(ISIG, 0);
+
+	if ((env = getenv("W3M_IMG2SIXEL"))) {
+	    char *p;
+	    env = Strnew_charp(env)->ptr;
+	    while (n < 8 && (p = strchr(env, ' '))) {
+		*p = '\0';
+		if (*env != '\0') {
+		    argv[n++] = env;
+		}
+		env = p+1;
+	    }
+	    if (*env != '\0') {
+		argv[n++] = env;
+	    }
+	}
+	else {
+		argv[n++] = "img2sixel";
+	}
+	argv[n++] = "-l";
+	argv[n++] = do_anim ? "auto" : "disable";
+	argv[n++] = "-w";
+	sprintf(digit[0], "%d", w*pixel_per_char_i);
+	argv[n++] = digit[0];
+	argv[n++] = "-h";
+	sprintf(digit[1], "%d", h*pixel_per_line_i);
+	argv[n++] = digit[1];
+	argv[n++] = "-c";
+	sprintf(clip, "%dx%d+%d+%d", sw*pixel_per_char_i, sh*pixel_per_line_i,
+			sx*pixel_per_char_i, sy*pixel_per_line_i);
+	argv[n++] = clip;
+	argv[n++] = url;
+	if (getenv("TERM") && strcmp(getenv("TERM"), "screen") == 0 &&
+	    (!getenv("SCREEN_VARIANT") || strcmp(getenv("SCREEN_VARIANT"), "sixel") != 0)) {
+	    argv[n++] = "-P";
+	}
+	argv[n++] = NULL;
+	execvp(argv[0],argv);
+	exit(0);
+    }
+    else if (pid > 0) {
+	int status;
+	waitpid(pid, &status, 0);
+	ttymode_reset(ISIG, 0);
+	mySignal(SIGINT, previntr);
+	mySignal(SIGQUIT, prevquit);
+	mySignal(SIGTSTP, prevstop);
+	if (do_anim) {
+	    writestr("\x1b[?80l");
+	}
+    }
+
+    MOVE(Currentbuf->cursorY,Currentbuf->cursorX);
+}
+
+int
+get_pixel_per_cell(int *ppc, int *ppl)
+{
+    fd_set  rfd;
+    struct timeval tval;
+    char buf[100];
+    char *p;
+    ssize_t len;
+    ssize_t left;
+    int wp,hp,wc,hc;
+    int i;
+
+#ifdef  TIOCGWINSZ
+    struct winsize ws;
+    if (ioctl(tty, TIOCGWINSZ, &ws) == 0 && ws.ws_ypixel > 0 && ws.ws_row > 0 &&
+        ws.ws_xpixel > 0 && ws.ws_col > 0) {
+	*ppc = ws.ws_xpixel / ws.ws_col;
+	*ppl = ws.ws_ypixel / ws.ws_row;
+	return 1;
+    }
+#endif
+
+    fputs("\x1b[14t\x1b[18t",ttyf); flush_tty();
+
+    p = buf;
+    left = sizeof(buf) - 1;
+    for (i = 0; i < 10; i++) {
+	tval.tv_usec = 200000;	/* 0.2 sec * 10 */
+	tval.tv_sec = 0;
+	FD_ZERO(&rfd);
+	FD_SET(tty,&rfd);
+	if (select(tty+1,&rfd,NULL,NULL,&tval) <= 0 || ! FD_ISSET(tty,&rfd))
+	    continue;
+
+	if ((len = read(tty,p,left)) <= 0)
+	    continue;
+	p[len] = '\0';
+
+	if (sscanf(buf,"\x1b[4;%d;%dt\x1b[8;%d;%dt",&hp,&wp,&hc,&wc) == 4) {
+	    if (wp > 0 && wc > 0 && hp > 0 && hc > 0) {
+		*ppc = wp / wc;
+		*ppl = hp / hc;
+		return 1;
+	    }
+	    else {
+		return 0;
+	    }
+	}
+	p += len;
+	left -= len;
+    }
+
+    return 0;
+}
+
 #ifdef USE_MOUSE
 #define W3M_TERM_INFO(name, title, mouse)	name, title, mouse
 #define NEED_XTERM_ON   (1)
diff --git a/w3mimg/x11/x11_w3mimg.c b/w3mimg/x11/x11_w3mimg.c
index cef72e2..bc8d0aa 100644
--- a/w3mimg/x11/x11_w3mimg.c
+++ b/w3mimg/x11/x11_w3mimg.c
@@ -121,16 +121,21 @@ x11_init(w3mimg_op * self)
     if (self == NULL)
 	return 0;
     xi = (struct x11_info *)self->priv;
+#if defined(USE_IMLIB)
     if (xi == NULL)
 	return 0;
-#if defined(USE_IMLIB)
     if (!xi->id) {
 	xi->id = Imlib_init(xi->display);
 	if (!xi->id)
 	    return 0;
     }
 #elif defined(USE_GDKPIXBUF)
-    if (!xi->init_flag) {
+    if (!xi) {
+#if defined(USE_GTK2)
+	g_type_init();
+#endif
+    }
+    else if (!xi->init_flag) {
 #if defined(USE_GTK2)
 	g_type_init();
 #endif
@@ -138,7 +143,7 @@ x11_init(w3mimg_op * self)
 	xi->init_flag = TRUE;
     }
 #endif
-    if (!xi->imageGC) {
+    if (xi && !xi->imageGC) {
 	xi->imageGC = XCreateGC(xi->display, xi->parent, 0, NULL);
 	if (!xi->imageGC)
 	    return 0;
@@ -653,9 +658,11 @@ x11_get_image_size(w3mimg_op * self, W3MImage * img, char *fname, int *w,
 
     if (self == NULL)
 	return 0;
+#if defined(USE_IMLIB) && defined(USE_IMLIB2)
     xi = (struct x11_info *)self->priv;
     if (xi == NULL)
 	return 0;
+#endif
 
 #if defined(USE_IMLIB)
     im = Imlib_load_image(xi->id, fname);
@@ -755,6 +762,9 @@ w3mimg_x11open()
 	return NULL;
     memset(wop, 0, sizeof(w3mimg_op));
 
+    if (getenv("W3M_USE_REMOTE_IMAGE"))
+	goto  end;
+
     xi = (struct x11_info *)malloc(sizeof(struct x11_info));
     if (xi == NULL)
 	goto error;
@@ -807,6 +817,7 @@ w3mimg_x11open()
 
     wop->priv = xi;
 
+  end:
     wop->init = x11_init;
     wop->finish = x11_finish;
     wop->active = x11_active;
